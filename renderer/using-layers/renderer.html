<!DOCTYPE html>
<html>
  <body>
    <script type="module">
      /**************************************************************************************
       *
       * This is a basic Renderer that renders Graphics on layers.
       *
       * Graphics are rendered in realtime.
       * It has no Renderer-specific actions
       * It exposes 10 RenderTargets (ie "Layers")
       * Each Layer can have 0 or 1 GraphicInstance playing
       * If loading a new GraphicInstance on a Layer, the previous one is cleared
       *
       *
       *************************************************************************************/

      setTimeout(() => setup().catch(console.error), 1);

      async function setup() {
        setupBackground();

        setupConstants();
        /** URL to send server requests to: */
        const serverApiUrl = "http://localhost:8080";
        /** URL to open websocket connection to */
        // const rendererApiUrl = 'ws://localhost:8080/rendererApi/v1'
        const rendererApiUrl = "ws://localhost:8080";
        // const rendererApiUrl = 'ws://google.com'

        const graphicCache = new GraphicCache(serverApiUrl);
        const layersManager = new LayersManager(graphicCache);
        const rendererApi = new RendererApiHandler(layersManager);
        // Connect to Server:
        await rendererApi.connect(rendererApiUrl + "/rendererApi/v1");
      }
      function setupBackground() {
        const urlParams = new URLSearchParams(window.location.search);
        const background = urlParams.get("background");
        if (background === "1") {
          const bg = document.getElementById("background-logo");

          bg.style.backgroundSize = `25vw`;
          bg.style.backgroundImage = `url('ograf_logo_colour_draft.svg')`;
          // bg.style.opacity = 0.5;
          const bg2 = document.getElementById("background-checkerboard");
          // bg2.style.background = `rgba(255,255,255,0.9)`;

          const checkerboardColor = "#ccc";
          bg2.style.backgroundImage = `linear-gradient(45deg, ${checkerboardColor} 25%, transparent 25%), linear-gradient(-45deg, ${checkerboardColor} 25%, transparent 25%), linear-gradient(45deg, transparent 75%, ${checkerboardColor} 75%), linear-gradient(-45deg, transparent 75%, ${checkerboardColor} 75%)`;
          bg2.style.backgroundSize = `20px 20px`;
          bg2.style.backgroundPosition = `0 0, 0 10px, 10px -10px, -10px 0px`;

          // const animateBackground = () => {
          //   const position = (1 + Math.sin(Date.now() / 10000)) * 0.5 * 75;

          //   bg.style.backgroundPositionX = `${position}vw`;
          //   bg.style.backgroundPositionY = `0vh`;

          //   window.requestAnimationFrame(animateBackground);
          // };
          // animateBackground();
        }
      }
      const constants = {};
      function setupConstants() {
        const urlParams = new URLSearchParams(window.location.search);

        constants.name = urlParams.get("name") || "Unnamed Renderer";
        constants.id = urlParams.get("id") || undefined;

        document.title = `Renderer | ${constants.name}`;
      }

      class RendererApiHandler {
        constructor(layersManager) {
          this.layersManager = layersManager;
          this.id = 0;
          this.waitingForReply = new Map();
          this.ws = null;
          this.actions = {
            "shake-it": (params) => {
              console.log("params", params);

              const endTime = Date.now() + (params.duration || 0);

              const shakeIt = () => {
                const el = document.querySelector("#main-container");
                if (Date.now() < endTime) {
                  el.style.transform = `rotate3d(${Math.random()}, ${Math.random()}, ${Math.random()}, ${
                    Math.random() * 5
                  }deg)`;

                  setTimeout(() => {
                    shakeIt();
                  }, 1000 / 30);
                } else {
                  el.style.transform = "";
                }
              };

              shakeIt();
            },
          }; // RendererActions
          this.rendererId = "N/A";

          this.connected = false;

          /** Unix timestamp, last reconnect attempt*/
          this.lastReconnect = 0;

          // Reconnection logic:
          setInterval(() => {
            if (!this.rendererApiUrl) return;
            if (this.connected) return;

            const timeSinceLastReconnect = Date.now() - this.lastReconnect;
            if (timeSinceLastReconnect < 5000) return;

            this.lastReconnect = Date.now();
            this.connect();
          }, 1000);
        }
        connect(rendererApiUrl) {
          if (rendererApiUrl) this.rendererApiUrl = rendererApiUrl;

          console.log("connecting to Renderer API at", this.rendererApiUrl);
          this.ws = new WebSocket(this.rendererApiUrl);

          this.ws.onopen = (ev) => {
            console.log("Connected to Renderer API", ev);

            this.connected = true;

            // The first thing the render MUST do after connecting is send a "register" message
            this._sendMessage("register", {
              info: this.getInfo().rendererInfo,
            })
              .then((response) => {
                console.log("Registered, ready to go!");
                this.rendererId = response.rendererId;
              })
              .catch((error) => {
                console.error("Failed to register with Renderer API:", error);
              });
          };

          this.ws.onmessage = (event) => {
            console.log("Received message:", event.data);
            const message = JSON.parse(event.data);

            // Handle incoming message:

            if (message.method) {
              try {
                const fcn = this[message.method];
                if (typeof fcn === "function") {
                  Promise.resolve(fcn.call(this, message.params))
                    .then((result) => {
                      this._replyMessage(message.id, null, result);
                    })
                    .catch((err) => {
                      console.error(err);
                      this._replyMessage(
                        message.id,
                        { code: 400, message: err.message },
                        null
                      );
                    });
                } else {
                  throw new Error(`Unknown method: "${message.method}"`);
                }
              } catch (err) {
                console.error("Error handling message:", err);
                this._replyMessage(
                  message.id,
                  { code: 400, message: err.message },
                  null
                );
              }
            } else {
              // is a reply
              const waiting = this.waitingForReply.get(message.id);
              if (!waiting) return;
              if (message.error) {
                waiting.reject(message.error);
              } else {
                waiting.resolve(message.result);
              }
            }
          };

          this.ws.onclose = (ev) => {
            console.log("Connection to Renderer API closed", ev);

            this.connected = false;
          };

          this.ws.onerror = (error) => {
            console.error("Error in connection to Renderer API:", error);
          };
        }
        _sendMessage(method, params) {
          console.log("Send message", method, params);
          /*
                        register: (params: { info: Partial<RendererInfo> } & VendorExtend) => PromiseLike<EmptyPayload>
                        unregister: (params: EmptyPayload) => PromiseLike<EmptyPayload>
                        status: (params: { status: RendererInfo } & VendorExtend) => PromiseLike<EmptyPayload>
                        debug: (params: { message: string } & VendorExtend) => PromiseLike<EmptyPayload>
                    */

          return new Promise((resolve, reject) => {
            const id = this.id++;
            this.ws.send(
              JSON.stringify({
                jsonrpc: "2.0",
                id,
                method,
                params,
              })
            );
            this.waitingForReply.set(id, { resolve, reject });
          });
        }
        _replyMessage(id, error, result) {
          console.log("send Reply", error, result);
          if (error) {
            this.ws.send(
              JSON.stringify({
                jsonrpc: "2.0",
                id,
                error,
              })
            );
          } else {
            this.ws.send(
              JSON.stringify({
                jsonrpc: "2.0",
                id,
                result: result ?? null,
              })
            );
          }
        }

        getManifest(_params) {
          // JSON RPC Method
          return {
            rendererManifest: {
              id: this.rendererId,
              name: constants.name,
              description: "A basic browser-based, layered Renderer",
              actions: {},

              renderTargets: this.layersManager.getAllLayers().map((layer) => {
                return {
                  id: layer.id,
                  name: `Layer ${layer.id}`,
                  // description: `Layer ${layer.id}`
                };
              }),
            },
          };
        }
        // listGraphicInstances (_params) {
        //     // JSON RPC Method
        //     return { graphicInstances: layersManager.listGraphicInstances() }
        // }
        getInfo(_params) {
          // JSON RPC Method
          return {
            rendererInfo: {
              id: constants.id || "",
              name: constants.name,
              // description?: string
              // targets: this.layersManager.getAllLayers().map((layer) => ({
              //   id: layer.id,
              //   name: `Layer ${layer.id}`,
              //   // description: `Layer ${layer.id}`
              // })),
              customActions: [
                {
                  id: "shake-it",
                  name: "Shake it up!",
                  schema: {
                    type: "object",
                    properties: {
                      duration: {
                        type: "number",
                        title: "Duration (ms)",
                        default: 2000,
                      },
                    },
                  },
                },
              ],
              renderTargetSchema: {
                type: "object",
                properties: {
                  layerId: {
                    /**
                     * This Renderer uses a string to identify its layers:
                     * Using the GDD Select to define the layer.
                     * @see https://superflytv.github.io/GraphicsDataDefinition/#select
                     */
                    type: "string",
                    title: "Layer",
                    enum: this.layersManager
                      .getAllLayers()
                      .map((layer) => layer.renderTarget.layerId),
                    gddType: "select",
                    gddOptions: {
                      labels: Object.fromEntries(
                        this.layersManager
                          .getAllLayers()
                          .map((layer) => [
                            layer.renderTarget.layerId,
                            layer.name,
                          ])
                      ),
                    },
                  },
                },
                default: this.layersManager.getAllLayers()[0].renderTarget,
              },
              // renderCharacteristics?: components["schemas"]["RenderCharacteristics"];
              status: {
                status: "ok", // OK, WARNING, ERROR
                // message: ''
                renderTargets: this.layersManager
                  .getAllLayers()
                  .map((layer) => {
                    if (!layer.graphicInstance) return null;

                    return layer.getInfo();
                  })
                  .filter(Boolean),
              },
            },
          };
        }
        getTargetStatus(params) {
          // JSON RPC Method
          console.log("getTargetStatus", getTargetStatus);

          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer)
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );

          return {
            renderTargetInfo: layer.getInfo(),
          };
        }
        /** Invokes an action on the Renderer. Actions are defined by the Renderer Manifest */
        async invokeRendererAction(params) {
          // JSON RPC Method
          const fcn = this.actions[params.action.id];
          if (!fcn) throw new Error(`Unknown action: ${params.action.id}`);
          return { value: await fcn(params.action.payload) };
        }

        /** Instantiate a Graphic on a RenderTarget. Returns when the load has finished. */
        async loadGraphic(params) {
          // JSON RPC Method
          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer) {
            console.log(
              "layers",
              this.layersManager.getAllLayers(),
              renderTarget.layerId
            );
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );
          }

          console.log("params", params);
          return layer.loadGraphic(params.graphicId, params.params);
        }
        /** Clear/unloads a GraphicInstance on a RenderTarget */
        clearGraphic(params) {
          // JSON RPC Method
          // console.log('params', params)

          let layers = [];
          if (params.filters?.renderTarget) {
            const layer = this.layersManager.getLayer(
              params.filters?.renderTarget
            );
            if (!layer)
              throw new Error(
                `Layer not found: ${JSON.stringify(
                  params.filters?.renderTarget
                )}`
              );
            layers = [layer];
          } else {
            layers = this.layersManager.getAllLayers();
          }

          const clearedGraphicInstancesOnLayer = [];
          for (const layer of layers) {
            const graphicInstance = layer.getGraphicInstance(
              params.filters?.graphicId
            );

            if (graphicInstance) {
              // Should it be cleared?
              let clear = true;
              if (
                params.filters?.graphic &&
                graphicInstance.graphicId !== params.filters?.graphicId
              )
                clear = false;
              if (
                params.filters?.graphicInstanceId &&
                graphicInstance.id !== params.filters?.graphicInstanceId
              )
                clear = false;

              if (clear) {
                layer.clearGraphic();

                clearedGraphicInstancesOnLayer.push({
                  renderTarget: layer.id,
                  graphicInstanceId: graphicInstance.id,
                  graphicId: graphicInstance.graphicId,
                });
              }
            }
          }

          return {
            graphicInstance: clearedGraphicInstancesOnLayer,
          };
        }
        /** Invokes an action on a graphicInstance. Actions are defined by the Graphic's manifest */
        async invokeGraphicUpdateAction(params) {
          // JSON RPC Method
          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer)
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );

          return layer.invokeUpdateAction(params);
        }
        async invokeGraphicPlayAction(params) {
          // JSON RPC Method
          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer)
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );

          return layer.invokePlayAction(params);
        }
        async invokeGraphicStopAction(params) {
          // JSON RPC Method
          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer)
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );

          return layer.invokeStopAction(params);
        }
        async invokeGraphicCustomAction(params) {
          // JSON RPC Method
          const layer = this.layersManager.getLayer(params.renderTarget);
          if (!layer)
            throw new Error(
              `Layer not found: ${JSON.stringify(params.renderTarget)}`
            );

          return layer.invokeCustomAction(params);
        }
      }

      class LayersManager {
        constructor(graphicCache) {
          this.graphicCache = graphicCache;

          this.layers = {};

          // Create 10 layers
          for (let i = 0; i < 5; i++) {
            const renderTarget = {
              layerId: `layer-${i}`,
            };

            this.layers[renderTarget.layerId] = new LayerHandler(
              graphicCache,
              renderTarget,
              `Layer ${i}`,
              i
            );
          }
        }

        getLayer(renderTarget) {
          return this.layers[renderTarget.layerId];
        }
        getAllLayers() {
          return Object.values(this.layers);
        }
      }
      class LayerHandler {
        constructor(graphicCache, renderTarget, name, zIndex) {
          this.graphicCache = graphicCache;
          this.renderTarget = renderTarget;
          this.name = name;
          this.graphicInstance = null;

          this.element = document.createElement("div");
          this.element.style.position = "fixed";
          this.element.style.top = 0;
          this.element.style.left = 0;
          this.element.style.right = 0;
          this.element.style.bottom = 0;
          this.element.style.zIndex = zIndex;

          document.getElementById("layers").appendChild(this.element);
        }
        getInfo() {
          console.log("this.graphicInstance", this.graphicInstance);
          // RenderTargetInfo
          return {
            renderTarget: this.renderTarget,
            name: this.name,
            status: "OK", // enum: OK, WARNING, ERROR
            // statusMessage: ''
            graphicInstances: this.graphicInstance
              ? [
                  {
                    graphicInstanceId: this.graphicInstance.id,
                    graphic: this.graphicInstance.graphicInfo.graphic,
                  },
                ]
              : [],
          };
          return {}; // RenderTargetStatus, TBD
        }
        listGraphicInstances() {
          return []; // TODO
        }

        async loadGraphic(graphicId, params) {
          // Clear any existing GraphicInstance:
          const existing = this.getGraphicInstance();
          if (existing) {
            this.clearGraphic();
          }

          const { elementName, graphicInfo } =
            await this.graphicCache.loadGraphic(graphicId);

          // Add element to DOM:
          const element = document.createElement(elementName);
          this.element.appendChild(element);

          this.graphicInstance = new GraphicInstance(
            graphicId,
            element,
            graphicInfo
          );

          // Load the element:
          let result = await element.load({
            renderType: "realtime",
            // renderCharacteristics: {} // TODO
            data: params.data,
          });

          if (!result) result = { statusCode: 200 };

          return {
            graphicInstanceId: this.graphicInstance.id,
            result,
          };
        }
        async clearGraphic() {
          const existing = this.getGraphicInstance();
          console.log("Clearing GraphicInstance", existing);
          if (existing) {
            try {
              await existing.element.dispose({});
            } catch (err) {
              console.error("Error disposing GraphicInstance:", err);
            } finally {
              this.element.innerHTML = "";
              this.graphicInstance = null;
            }
          }
        }

        getGraphicInstance() {
          return this.graphicInstance;
        }
        _findGraphicsInstance(params) {
          const graphicInstance = this.getGraphicInstance();
          if (!graphicInstance)
            throw new Error(
              `No GraphicInstance on Layer ${params.renderTarget}`
            );

          const targetMatch = params.target.graphicId
            ? params.target.graphicId === graphicInstance.graphicId
            : params.target.graphicInstanceId === graphicInstance.id;
          if (!targetMatch)
            throw new Error(
              `No GraphicInstance found matching graphicTarget: ${JSON.stringify(
                params.graphicTarget
              )}`
            );
          return graphicInstance;
        }
        async invokeUpdateAction(params) {
          const graphicsInstance = this._findGraphicsInstance(params);
          let result = await graphicsInstance.element.updateAction(
            params.params
          );
          if (!result) result = { statusCode: 200 };
          return {
            graphicsInstanceId: graphicsInstance.id,
            result,
          };
        }
        async invokePlayAction(params) {
          const graphicsInstance = this._findGraphicsInstance(params);

          let result = await graphicsInstance.element.playAction(params.params);
          if (!result) result = { statusCode: 200 }; // Not valid in spec, by cheap to handle
          if (!result.statusCode) result.statusCode = 200;

          return {
            graphicsInstanceId: graphicsInstance.id,
            result,
          };
        }
        async invokeStopAction(params) {
          const graphicsInstance = this._findGraphicsInstance(params);

          let result = await graphicsInstance.element.stopAction(params.params);
          if (!result) result = { statusCode: 200 };
          return {
            graphicsInstanceId: graphicsInstance.id,
            result,
          };
        }
        async invokeCustomAction(params) {
          const graphicsInstance = this._findGraphicsInstance(params);

          let result = await graphicsInstance.element.customAction(
            params.params
          );
          if (!result) result = { statusCode: 200 };
          return {
            graphicsInstanceId: graphicsInstance.id,
            result,
          };
        }
        // Not supported in a realtime renderer, so not implemented here:
        // gotoTime
        // setActionsSchedule
      }
      let graphicInstanceId = 0;
      class GraphicInstance {
        constructor(id, element, graphicInfo) {
          this.id = `${graphicInstanceId++}`;
          this.element = element;
          this.graphicId = id;
          this.graphicInfo = graphicInfo;
        }
      }

      class GraphicCache {
        constructor(serverApiUrl) {
          this.serverApiUrl = serverApiUrl;
          this.cachedGraphicInfo = {};
        }
        async loadGraphic(graphicId) {
          // Check if the Graphic is already registered:
          const cachedGraphic = customElements.get(graphicId);
          const cachedGraphicInfo = this.cachedGraphicInfo[graphicId];
          if (cachedGraphic && cachedGraphicInfo)
            return { elementName: graphicId, graphicInfo: cachedGraphicInfo };

          console.log(`Loading Graphic "${graphicId}"`);

          console.log(`Loading manifest...`);
          const graphicInfo = await this.fetchGraphicInfo(graphicId);

          this.cachedGraphicInfo[graphicId] = graphicInfo;

          // Load the Graphic:
          console.log(`Loading Graphic...`, graphicInfo);
          const webComponent = await this.fetchModule(
            graphicId,
            graphicInfo.manifest
          );

          // register the web component
          customElements.define(graphicId, webComponent);

          return {
            elementName: graphicId,
            graphicInfo,
          };
        }
        async fetchGraphicInfo(graphicId) {
          const manifestUrl = `${this.serverApiUrl}/ograf/v1/graphics/${graphicId}`;

          const response = await fetch(manifestUrl);
          if (response.status === 200) {
            const responseData = await response.json();

            // console.log("responseData", responseData);

            if (!responseData.graphic)
              throw new Error('No "graphic" property found in response');
            if (!responseData.manifest)
              throw new Error('No "manifest" property found in response');

            return responseData;
          } else {
            throw new Error(
              `Failed to load manifest from ${manifestUrl}: [${
                response.status
              }] ${JSON.stringify(response.body)}`
            );
          }
        }
        async fetchModule(id, manifest) {
          const modulePath = `${
            this.serverApiUrl
          }/serverApi/internal/graphics/${id}/${
            manifest.main ?? "graphic.mjs"
          }`;

          // Load the Graphic module:
          const module = await import(modulePath);

          if (!module.default) {
            console.log("module", module);

            const exportKeys = Object.keys(module);

            if (exportKeys.length) {
              throw new Error(
                `The Graphic is expected to export a class as a default export. ${
                  exportKeys.length === 1
                    ? `Instead there is a export called "${exportKeys[0]}". Change this to be "export default ${exportKeys[0]}".`
                    : `Instead there are named exports: ${exportKeys.join(
                        ", "
                      )}.`
                }`
              );
            } else {
              throw new Error(
                "Module expected to export a class as a default export (no exports found)"
              );
            }
          }
          if (typeof module.default !== "function") {
            console.log("module", module);
            throw new Error(
              "The Graphic is expected to default export a class"
            );
          }

          return module.default;
        }
      }

      function pathJoin(paths) {
        return paths.join("/").replace(/\/+/g, "/");
      }
    </script>

    <style>
      #main-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -2;
      }

      #background-logo {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        /* background-size: 300px; */
        /* background-position: center; */
        background-repeat: no-repeat;
        z-index: -1;
      }
      #background-checkerboard {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -2;
      }
    </style>

    <div id="main-container">
      <div id="background-logo"></div>
      <div id="background-checkerboard"></div>
      <div>
        <div id="layers"></div>
      </div>
    </div>
  </body>
</html>
